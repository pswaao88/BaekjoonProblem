# 2026년 01월 20일 알고리즘 백준 노트

오늘 해결한 문제들을 기반으로 복습 시 빠르게 핵심을 떠올릴 수 있도록 정리합니다.

---

## 1. 문제 풀이 요약

### [9935] 문자열 폭발

- **티어**: Gold IV
- **문제 링크**: https://www.acmicpc.net/problem/9935

- **핵심 목표**:

  - 주어진 문자열에서 특정 '폭발 문자열'이 나타나면 제거하는 과정을 반복하여 최종 문자열을 구한다.

- **접근 전략 (Why)**:

  - 문자열 길이가 최대 1,000,000이므로, `String.replace`와 같이 매번 새로운 문자열을 생성하는 $O(N \times M)$ 방식은 시간 초과가 예상된다. 마지막에 추가된 문자를 기준으로 폭발 문자열을 검사하고 제거하는 LIFO(후입선출) 특성이 필요하므로, $O(N)$에 해결 가능한 **스택(Stack)** 자료구조가 가장 효율적이다.

- **주요 개념**:

  - 스택, 문자열 처리

- **실수 포인트 / 함정**:

  - 폭발 문자열이 터진 후, 스택의 그 이전 상태가 새로운 폭발 문자열의 시작 부분이 될 수 있는 경우를 놓치기 쉽다.
  - 폭탄이 터진 후, 다음에 비교해야 할 폭탄 문자의 인덱스를 정확히 되돌리는 로직이 중요하다.

- **시도했으나 버린 접근**:

  - `while` 루프 내에서 `String.replace()` 또는 `replaceAll()`을 계속 호출하는 접근. 문자열 길이가 길면 매번 전체 문자열을 탐색하고 새로운 문자열 객체를 생성하는 비용이 커서 반드시 시간 초과가 발생한다.

- **성능 분석**:

  - **시간 복잡도**: $O(N)$
  - **공간 복잡도**: $O(N)$

- **기억할 핵심 코드**:

```java
// 스택의 top이 폭탄의 마지막 문자와 일치할 때, 폭탄 길이만큼 스택을 확인하여 전체 일치 여부 판단
if (charStack.size() >= bomb.length && /* ... 폭탄 문자열과 일치하는지 검사 ... */) {
    // 일치한다면 폭탄 길이만큼 pop
    for (int j = 0; j < bomb.length; j++) {
        charStack.pop();
    }
}
```

---

### [5525] IOIOI

- **티어**: Silver I
- **문제 링크**: https://www.acmicpc.net/problem/5525

- **핵심 목표**:

  - 문자열 S에서 $P_N$(`IO`가 N번 반복되고 `I`로 끝남) 패턴이 몇 번 나타나는지 찾는다.

- **접근 전략 (Why)**:

  - S의 길이가 최대 1,000,000이므로, 전체를 순회하는 $O(M)$ 이내의 풀이가 필요하다. $P_N$ 패턴의 구조가 `IOI...`로 단순하고 반복적이므로, KMP 같은 복잡한 알고리즘 대신, 문자열을 한 번만 순회하며 'IOI' 패턴의 연속성만 세는 것으로 충분하다.

- **주요 개념**:

  - 문자열 검색, 패턴 매칭

- **실수 포인트 / 함정**:

  - `IOIOIOI` (N=2) 에서 `IOIOI`는 2번 나타난다. 즉, 겹치는 패턴을 세어야 한다. 패턴 하나를 찾고 나서 인덱스를 패턴 길이만큼 점프시키면 겹치는 경우를 놓칠 수 있다.

- **시도했으나 버린 접근**:

  - `S.substring()`과 `equals()`로 S의 모든 위치에서 $P_N$ 문자열을 직접 생성하여 비교하는 접근. 매번 $P_N$ 문자열을 생성하고 비교하는 비용이 커서 비효율적이다.

- **성능 분석**:

  - **시간 복잡도**: $O(M)$ (M은 S의 길이)
  - **공간 복잡도**: $O(M)$

- **기억할 핵심 코드**:

```java
if (S[i] == 'O' && S[i-1] == 'I' && S[i+1] == 'I') {
    oiCount++;
    if (oiCount == N) {
        count++;
        oiCount--; // 핵심: 겹치는 패턴을 세기 위해 카운트를 하나 줄여줌
    }
    i++; // 'OI'를 찾았으니 다음 탐색은 한 칸 건너뛰어도 됨
} else {
    oiCount = 0;
}
```

---

### [11478] 서로 다른 부분 문자열의 개수

- **티어**: Silver III
- **문제 링크**: https://www.acmicpc.net/problem/11478

- **핵심 목표**:

  - 주어진 문자열에서 생성 가능한 모든 부분 문자열 중, 중복을 제외한 유일한 것의 개수를 센다.

- **접근 전략 (Why)**:

  - 문자열 길이가 1,000으로 비교적 짧아 $O(L^2)$ 복잡도까지 허용된다. '서로 다른'이라는 조건은 중복을 허용하지 않는 **해시셋(HashSet)**을 사용하기에 최적의 상황이다. 모든 부분 문자열($O(L^2)$)을 생성하여 `HashSet`에 넣으면($O(1)$) 간단히 해결된다.

- **주요 개념**:

  - 해시셋(HashSet), 브루트포스, 문자열

- **실수 포인트 / 함정**:

  - 부분 문자열의 길이나 시작/끝 인덱스 범위를 잘못 계산하여 일부 경우를 누락할 수 있다. 이중 for문으로 길이를 기준으로 생성하면 실수를 줄일 수 있다.

- **시도했으나 버린 접근**:

  - 이 문제에서는 브루트포스와 `HashSet` 조합이 가장 표준적인 풀이이다. 더 복잡한 자료구조(Trie, Suffix Array)는 문제 제약 조건 하에서는 불필요한 오버 엔지니어링이다.

- **성능 분석**:

  - **시간 복잡도**: $O(L^2)$ (L은 문자열 길이)
  - **공간 복잡도**: $O(L^2)$

- **기억할 핵심 코드**:

```java
HashSet<String> set = new HashSet<>();
for (int i = 1; i <= s.length(); i++) { // 부분 문자열의 길이 (1부터 L까지)
    for (int j = 0; j <= s.length() - i; j++) { // 시작 위치
        set.add(s.substring(j, j + i));
    }
}
```

---

### [14425] 문자열 집합

- **티어**: Silver IV
- **문제 링크**: https://www.acmicpc.net/problem/14425

- **핵심 목표**:

  - 집합 S에 포함된 N개의 문자열 중, 별도로 주어지는 M개의 문자열이 몇 개나 포함되어 있는지 확인한다.

- **접근 전략 (Why)**:

  - N과 M이 최대 10,000이므로, $O(N \times M)$ 복잡도는 시간 초과. 집합에 '포함되어 있는지' 여부를 빠르게($O(1)$) 확인하는 것이 핵심이므로, **해시셋(HashSet)**이 최적의 자료구조이다.

- **주요 개념**:

  - 해시셋(HashSet), 자료구조 활용

- **실수 포인트 / 함정**:

  - 자료구조의 시간 복잡도를 고려하지 않고 `ArrayList`와 같은 선형 탐색 자료구조를 선택하면 반드시 시간 초과가 발생한다.

- **시도했으나 버린 접근**:

  - `ArrayList`에 N개의 문자열을 저장하고, M개의 문자열에 대해 `list.contains()`를 호출하는 방식. 리스트의 `contains`는 내부적으로 선형 탐색($O(N)$)을 하므로 시간 초과된다.

- **성능 분석**:

  - **시간 복잡도**: $O(L_{N} \cdot N + L_{M} \cdot M)$
  - **공간 복잡도**: $O(L_{N} \cdot N)$

- **기억할 핵심 코드**:

```java
HashSet<String> S = new HashSet<>();
for (int i = 0; i < N; i++) {
    S.add(br.readLine());
}
// ...
for (int i = 0; i < M; i++) {
    if (S.contains(now)) { // 평균 O(1) 시간 복잡도로 존재 여부 확인
        count++;
    }
}
```

---

## 2. 오늘의 정리 (주요 개념 학습)

### [자료구조 선택의 중요성]

- **핵심아이디어**:

  - **자료구조의 올바른 선택이 곧 알고리즘의 효율성이다.** 문제의 제약 조건(시간, 데이터 크기)을 분석하여 선형 탐색($O(N)$)이 아닌, 상수 시간($O(1)$) 또는 로그 시간($O(\log N)$) 조회가 가능한 자료구조(스택, 해시셋)를 선택하는 것이 시간 초과를 피하는 핵심이다.

- **판단기준**:

  1. 입력 데이터의 크기가 큰가? ($N \ge 100,000$) -> $O(N^2)$ 불가, $O(N \log N)$ 이나 $O(N)$ 알고리즘 필요.
  2. '중복 없는' 또는 '존재 여부 확인' 조건이 있는가? -> `HashSet` 사용을 최우선으로 고려.
  3. 데이터가 순차적으로 쌓이고 마지막 데이터부터 처리해야 하는가? (LIFO) -> `Stack` 사용을 고려.

- **연계 문제 / 키워드**:
  - 스택 활용: 17298(오큰수), 1874(스택 수열), 4949(균형잡힌 세상)
  - 해시셋 활용: 1764(듣보잡), 1620(나는야 포켓몬 마스터 이다솜)
  - 문자열 탐색: 1316(그룹 단어 체커), 1541(잃어버린 괄호)
