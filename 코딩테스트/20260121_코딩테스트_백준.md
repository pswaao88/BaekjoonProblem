# 2026년 01월 21일 알고리즘 백준 노트

오늘 해결한 문제들을 기반으로 복습 시 빠르게 핵심을 떠올릴 수 있도록 정리합니다.

---

## 1. 문제 풀이 요약

### [1120] 문자열

- **티어**: Silver IV
- **문제 링크**: https://www.acmicpc.net/problem/1120

- **핵심 목표**:

  - 문자열 A를 B의 부분 문자열과 비교하여, 차이가 가장 적게 나는 위치를 찾아 그 차이를 반환한다.

- **접근 전략 (Why)**:

  - A와 B의 길이가 최대 50으로 매우 짧다. 이는 완전 탐색(Brute-force)으로 충분히 해결 가능함을 시사한다.
  - B의 시작점(0)부터 A를 놓을 수 있는 마지막 위치(`B.length() - A.length()`)까지 **모든 경우를 순회**하며 차이를 계산하고, 그 중 최솟값을 찾는다.

- **주요 개념**:

  - 브루트포스, 완전 탐색, 슬라이딩 윈도우

- **실수 포인트 / 함정**:

  - 슬라이딩 시킬 반복문의 범위를 잘못 설정하기 쉽다. `i`는 `0`부터 `B.length() - A.length()`까지 순회해야 모든 경우를 커버할 수 있다.

- **시도했으나 버린 접근**:

  - 제약 조건이 작으므로, 더 복잡한 문자열 알고리즘을 고려하는 것은 불필요한 오버엔지니어링이다. 완전 탐색이 가장 직관적이고 확실하다.

- **성능 분석**:

  - **시간 복잡도**: $O((L_B - L_A) \times L_A)$ (A, B 문자열 길이)
  - **공간 복잡도**: $O(L_A + L_B)$

- **기억할 핵심 코드**:

```java
int minDiff = 51; // A, B의 최대 길이는 50
// B 위에서 A를 슬라이딩 시키는 루프
for (int i = 0; i <= B.length() - A.length(); i++) {
    int currentDiff = 0;
    // 현재 위치에서 A와 B의 부분 문자열 비교
    for (int j = 0; j < A.length(); j++) {
        if (A.charAt(j) != B.charAt(i + j)) {
            currentDiff++;
        }
    }
    minDiff = Math.min(minDiff, currentDiff);
}
```

---

### [1431] 시리얼 번호

- **티어**: Silver III
- **문제 링크**: https://www.acmicpc.net/problem/1431

- **핵심 목표**:

  - 주어진 여러 조건(길이, 숫자 합, 사전 순)에 따라 시리얼 번호를 정렬한다.

- **접근 전략 (Why)**:

  - 문제에 명시된 정렬 조건이 표준 라이브러리의 기본 정렬과 다르므로, **사용자 정의 정렬(Custom Sort)**이 필요하다.
  - `Comparator` 인터페이스(또는 람다식)를 구현하여 문제의 조건 순서대로 비교 로직을 작성하는 것이 가장 정석적인 방법이다.

- **주요 개념**:

  - `Comparator`, 사용자 정의 정렬, 람다식

- **실수 포인트 / 함정**:

  - 3가지 정렬 조건의 우선순위(길이 -> 숫자 합 -> 사전 순)를 정확히 지키지 않으면 틀린다.
  - 시리얼 번호 내 숫자의 합을 구할 때, 문자인 경우는 건너뛰고 숫자 `char`만 `int`로 변환하여 더해야 한다.

- **시도했으나 버린 접근**:

  - 이 문제는 '어떻게 정렬할 것인가'가 정해져 있으므로, 다른 접근 방식보다는 `Comparator` 구현의 정확성이 중요하다.

- **성능 분석**:

  - **시간 복잡도**: $O(N \log N \times L)$ (정렬 비교 시 문자열 길이 L만큼 소요)
  - **공간 복잡도**: $O(N \times L)$ (입력 저장 공간)

- **기억할 핵심 코드**:

```java
Arrays.sort(serials, (s1, s2) -> {
    // 1. 길이 비교
    if (s1.length() != s2.length()) {
        return Integer.compare(s1.length(), s2.length());
    }
    // 2. 숫자 합 비교
    int sum1 = getDigitSum(s1);
    int sum2 = getDigitSum(s2);
    if (sum1 != sum2) {
        return Integer.compare(sum1, sum2);
    }
    // 3. 사전순 비교
    return s1.compareTo(s2);
});
```

---

### [20920] 영단어 암기는 괴로워

- **티어**: Silver III
- **문제 링크**: https://www.acmicpc.net/problem/20920

- **핵심 목표**:

  - 단어들을 (1) 빈도, (2) 길이, (3) 사전 순서의 복합적인 우선순위에 따라 정렬한다.

- **접근 전략 (Why)**:

  - 정렬 기준에 '빈도'가 포함되므로, 먼저 각 단어의 빈도를 세는 과정이 필요하다. `HashMap`을 사용하여 $O(N)$으로 각 단어의 빈도를 효율적으로 계산할 수 있다.
  - 빈도 계산 후, `Comparator`를 이용한 사용자 정의 정렬을 통해 문제의 3가지 조건(빈도 내림차순, 길이 내림차순, 사전순 오름차순)을 구현한다.

- **주요 개념**:

  - `HashMap` (빈도수 계산), `Comparator` (사용자 정의 정렬)

- **실수 포인트 / 함정**:

  - 여러 정렬 조건의 우선순위와 오름차순/내림차순을 혼동하기 쉽다.
  - 문제의 조건(길이가 M 이상인 단어만)을 빠뜨리지 않도록 주의해야 한다.

- **시도했으나 버린 접근**:

  - 빈도를 미리 세지 않고 정렬 과정에서 매번 계산하려는 접근은 매우 비효율적이다. '계산'과 '정렬' 단계를 분리하는 것이 핵심이다.

- **성능 분석**:

  - **시간 복잡도**: $O(N \cdot L + U \log U \cdot L)$ (N: 총 단어, U: 유니크 단어, L: 평균 길이)
  - **공간 복잡도**: $O(U \cdot L)$

- **기억할 핵심 코드**:

```java
// 1. 빈도수 계산
Map<String, Integer> freq = new HashMap<>();
for(int i=0; i<N; i++) {
    String word = br.readLine();
    if(word.length() < M) continue;
    freq.put(word, freq.getOrDefault(word, 0) + 1);
}

// 2. 리스트로 변환 후 정렬
List<String> words = new ArrayList<>(freq.keySet());
Collections.sort(words, (w1, w2) -> {
    int freq1 = freq.get(w1);
    int freq2 = freq.get(w2);
    if (freq1 != freq2) return freq2 - freq1; // 빈도 내림차순
    if (w1.length() != w2.length()) return w2.length() - w1.length(); // 길이 내림차순
    return w1.compareTo(w2); // 사전순 오름차순
});
```

---

### [5052] 전화번호 목록

- **티어**: Gold IV
- **문제 링크**: https://www.acmicpc.net/problem/5052

- **핵심 목표**:

  - 주어진 전화번호 목록에 다른 번호의 접두사인 경우가 있는지 확인한다.

- **접근 전략 (Why)**:

  - 전화번호가 최대 10,000개이므로, 모든 쌍을 비교하는 $O(N^2)$ 접근은 시간 초과.
  - 전화번호를 사전순으로 **정렬**하면, 어떤 번호가 다른 번호의 접두어인 경우 그 두 번호는 반드시 인접하게 된다.
  - 따라서 정렬 후, 인접한 두 원소(`i`와 `i+1`)만 서로 접두어 관계인지 확인하면 되므로, $O(N \log N)$으로 해결 가능하다.

- **주요 개념**:

  - 문자열 정렬, 접두어(Prefix) 확인

- **실수 포인트 / 함정**:

  - 정렬하지 않고 모든 경우를 확인하려고 하면 시간 복잡도 계산에 실패한다.
  - 정렬 후, 모든 쌍을 다시 확인할 필요 없이 인접한 쌍만 확인하면 된다는 점을 놓치기 쉽다.

- **시도했으나 버린 접근**:

  - 이중 `for`문으로 모든 번호 쌍을 `startsWith()`로 비교하는 접근: $N$이 10,000일 때 약 $10^8$ 연산으로 시간 초과.
  - Trie 자료구조 사용: 정석적인 풀이 중 하나지만, 구현이 더 복잡하다. 정렬을 이용한 풀이가 코드도 간결하고 효율적이다.

- **성능 분석**:

  - **시간 복잡도**: $O(T \times (N \log N + N \times L))$ (T: 테스트케이스, N: 번호 수, L: 번호 길이)
  - **공간 복잡도**: $O(N \times L)$

- **기억할 핵심 코드**:

```java
// 정렬이 핵심 아이디어
Arrays.sort(phoneNumbers);

for (int i = 0; i < n - 1; i++) {
    // 정렬했기 때문에, 바로 다음 번호가 현재 번호로 시작하는지만 확인하면 된다.
    if (phoneNumbers[i+1].startsWith(phoneNumbers[i])) {
        isConsistent = false;
        break;
    }
}
```

---

### [9935] 문자열 폭발

- **티어**: Gold IV
- **문제 링크**: https://www.acmicpc.net/problem/9935

- **핵심 목표**:

  - 주어진 문자열에서 특정 '폭발 문자열'을 찾아 제거하는 과정을 반복하여 남은 최종 문자열을 구한다.

- **접근 전략 (Why)**:

  - 문자열 길이가 최대 1,000,000이므로, `String.replace`와 같이 매번 새로운 문자열을 생성하는 방식($O(N \cdot M)$)은 시간 초과가 발생한다.
  - 문자를 하나씩 추가하면서 마지막에 추가된 문자가 폭발 문자열의 일부를 완성하는지 검사하는 LIFO(후입선출) 구조가 적합하므로, **스택(Stack)**을 사용하는 것이 효율적이다.
  - 문자를 스택에 `push`하고, 스택의 상단이 폭발 문자열과 일치할 때마다 `pop`하면 $O(N)$에 해결할 수 있다.

- **주요 개념**:

  - 스택, 문자열 처리

- **실수 포인트 / 함정**:

  - 폭발이 일어난 후, 스택에 남아있는 문자열의 끝부분이 새로운 폭발 문자열의 시작과 이어져 또 다른 폭발을 일으킬 수 있는 경우를 스택은 자연스럽게 처리해준다. 이 점을 고려하지 않고 다른 방법으로 접근하면 로직이 복잡해진다.

- **시도했으나 버린 접근**:

  - `while` 루프와 `String.contains/replace` 조합: 문자열이 길 때 매번 전체를 탐색하고 새 문자열을 생성하는 비용이 커서 시간 초과가 발생한다.

- **성능 분석**:

  - **시간 복잡도**: $O(N \times L_{bomb})$ (최악의 경우), $O(N)$ (효율적 구현 시)
  - **공간 복잡도**: $O(N)$

- **기억할 핵심 코드**:

```java
StringBuilder sb = new StringBuilder();
for (char ch : originalString.toCharArray()) {
    sb.append(ch);
    if (sb.length() >= bombString.length()) {
        // 현재 sb의 끝이 폭발 문자열과 같은지 확인
        if (sb.substring(sb.length() - bombString.length()).equals(bombString)) {
            // 같다면 해당 길이만큼 삭제
            sb.delete(sb.length() - bombString.length(), sb.length());
        }
    }
}
```

---

## 2. 오늘의 정리 (주요 개념 학습)

### [정렬과 자료구조를 활용한 문제 해결]

- **핵심아이디어**:

  - **복잡한 조건은 '기준'을 만들어 해결한다.** 문제에서 주어진 조건(크기, 빈도, 순서 등)을 그대로 코드로 옮기는 것이 중요하다. 특히 정렬 문제는 `Comparator`를 얼마나 정확하게 구현하는지가 관건이다.
  - **데이터의 특성과 제약 조건을 보고 적합한 자료구조를 선택해야 시간 초과를 피할 수 있다.** (e.g., 탐색 속도가 중요하면 `HashMap`/`HashSet`, LIFO 구조는 `Stack`, 정렬된 순서 유지는 `PriorityQueue`나 `List` 정렬)

- **판단기준**:

  1.  **정렬 문제인가?** -> 요구하는 정렬 기준이 복잡한가? -> `Comparator` 구현을 떠올린다.
  2.  **데이터가 매우 큰가? ($>100,000$)** -> $O(N^2)$은 절대 안된다. $O(N \log N)$이나 $O(N)$ 풀이를 고민한다.
  3.  **'존재 여부', '중복 제거', '빈도수'** 키워드가 있는가? -> `HashMap` 또는 `HashSet`을 우선 고려한다.
  4.  **연속된 제거/삽입이 일어나는가?** -> `Stack`이나 `Queue`의 특성을 활용할 수 있는지 검토한다.

- **연계 문제 / 키워드**:

  - 사용자 정의 정렬: 10814(나이순 정렬), 11650(좌표 정렬하기)
  - 스택 활용: 17298(오큰수), 4949(균형잡힌 세상)
  - 해시맵 활용: 1764(듣보잡), 1620(나는야 포켓몬 마스터 이다솜)
  - 문자열 탐색/처리: 5525(IOIOI), 11478(서로 다른 부분 문자열의 개수)

```java
