# 2026년 01월 23일 알고리즘 백준 노트

오늘 해결한 문제들을 기반으로 복습 시 빠르게 핵심을 떠올릴 수 있도록 정리합니다.

---

## 1. 문제 풀이 요약

### [1593] 문자 해독

- **티어**: Gold V
- **문제 링크**: https://www.acmicpc.net/problem/1593

- **핵심 목표**:

  - 길이 g의 단어 W와 길이 S의 문자열 S가 주어질 때, S의 부분 문자열 중 W의 애너그램(순열)이 되는 경우의 수를 구한다.

- **접근 전략 (Why)**:

  - S의 길이가 최대 3,000,000이므로, $O(S \cdot g)$ 접근은 시간 초과. 고정된 크기 `g`의 부분 문자열을 검사하므로 **슬라이딩 윈도우** 기법이 최적이다.
  - 윈도우를 한 칸씩 이동하며 새로 추가되는 문자와 제거되는 문자의 개수만 갱신하면, 매번 전체를 비교할 필요 없이 $O(S)$ 시간에 해결 가능하다.

- **주요 개념**:

  - 슬라이딩 윈도우, 해시(배열 사용)

- **실수 포인트 / 함정**:

  - 대소문자를 구별해야 하므로, 카운팅 배열을 소문자용/대문자용으로 분리하거나 크기를 52로 설정해야 한다.
  - 윈도우를 이동시킬 때, 윈도우의 맨 앞(왼쪽)에서 빠지는 문자의 카운트를 정확히 빼줘야 한다.

- **시도했으나 버린 접근**:

  - S의 모든 부분 문자열을 `substring`으로 잘라내고 정렬하여, W를 정렬한 문자열과 비교하는 접근. 부분 문자열 생성 및 정렬에 비용이 커서($O(S \cdot g \log g)$) 시간 초과된다.

- **성능 분석**:

  - **시간 복잡도**: $O(S + g)$
  - **공간 복잡도**: $O(1)$ (알파벳 개수만큼의 고정된 크기)

- **기억할 핵심 코드**:

```java
// 윈도우를 오른쪽으로 한 칸 이동
// 새로운 문자 추가
if('a' <= S[i] && S[i] <= 'z'){
    nowLittleCharG[S[i] - 'a']++;
} else {
    nowBigCharG[S[i] - 'A']++;
}

// 비교
if (check()) count++;

// 맨 왼쪽 문자 제거
if('a' <= S[i-g+1] && S[i-g+1] <= 'z'){
    nowLittleCharG[S[i-g+1] - 'a']--;
} else {
    nowBigCharG[S[i-g+1] - 'A']--;
}
```

---

### [17609] 회문

- **티어**: Gold V
- **문제 링크**: https://www.acmicpc.net/problem/17609

- **핵심 목표**:

  - 주어진 문자열이 회문인지, 유사 회문(한 문자 제거 시 회문)인지, 둘 다 아닌지 판별한다.

- **접근 전략 (Why)**:

  - 문자열 길이가 최대 100,000. 일반적인 회문 검사는 양 끝에서 중앙으로 좁혀오는 **투 포인터** 방식으로 $O(N)$에 가능하다.
  - 유사 회문은, 투 포인터가 다른 문자를 만났을 때 (1) 왼쪽 문자를 건너뛰는 경우와 (2) 오른쪽 문자를 건너뛰는 경우, 이 두 가지 케이스만 추가로 검사하면 된다. 이 분기된 검사 역시 투 포인터로 진행할 수 있다.

- **주요 개념**:

  - 투 포인터, 재귀, 문자열

- **실수 포인트 / 함정**:

  - 문자가 다른 지점을 만났을 때, 왼쪽을 건너뛰는 경우와 오른쪽을 건너뛰는 경우 *둘 중 하나만* 성공해도 유사 회문으로 인정된다. 이 두 가지 분기를 모두 체크해야 한다.
  - 재귀로 구현 시, 유사 회문 체크 중에는 더 이상 문자를 제거할 수 없다는 것을 명확히 해야 한다(깊이(depth) 등으로 제어).

- **시도했으나 버린 접근**:

  - `for` 루프를 돌며 모든 문자를 하나씩 실제로 제거한 문자열을 만들고, 각각에 대해 회문 검사를 하는 방식. $O(N^2)$ 복잡도로 시간 초과.

- **성능 분석**:

  - **시간 복잡도**: $O(N)$ (최대 2번의 문자열 스캔)
  - **공간 복잡도**: $O(N)$ (재귀 호출 깊이, 문자열 변환)

- **기억할 핵심 코드**:

```java
// 문자가 다른 경우, 두 가지 가능성을 탐색
if(now[left] != now[right] ) {
    if(depth != 0){ // 이미 한번 문자를 제거했다면 실패
        return false;
    }
    boolean yes;
    // 1. 왼쪽 문자를 제거하고 나머지 부분이 회문인지 확인
    yes = pseudoPalindrome(left + 1, right, s, depth + 1);
    if(!yes){
        // 2. 1번이 실패했다면, 오른쪽 문자를 제거하고 확인
        yes = pseudoPalindrome(left, right - 1, s, depth + 1);
    }
    return yes;
}
```

---

### [5635] 생일

- **티어**: Silver V
- **문제 링크**: https://www.acmicpc.net/problem/5635

- **핵심 목표**:

  - N명의 학생 정보(이름, 일, 월, 년) 중 가장 나이가 많은 학생과 가장 적은 학생의 이름을 출력한다.

- **접근 전략 (Why)**:

  - N이 최대 100으로 매우 작기 때문에 어떤 방식을 써도 통과 가능하다.
  - 코드는 **`PriorityQueue`**를 두 개 사용하여, 하나는 나이가 가장 적은 사람(생년월일 내림차순 정렬), 다른 하나는 가장 많은 사람(생년월일 오름차순 정렬)을 효율적으로 찾고 있다.
  - 모든 데이터를 입력받은 후 `poll()`만 하면 $O(1)$으로 최댓값/최솟값을 얻을 수 있다.

- **주요 개념**:

  - `PriorityQueue` (우선순위 큐), `Comparator` (사용자 정의 정렬)

- **실수 포인트 / 함정**:

  - 정렬 기준의 우선순위(년 -> 월 -> 일)를 정확히 구현해야 한다.
  - 나이가 '적다'는 것은 생년월일 값이 '크다'는 의미이고, 나이가 '많다'는 것은 생년월일 값이 '작다'는 의미임을 혼동하지 않도록 주의해야 한다.

- **시도했으나 버린 접근**:

  - 모든 학생을 `List`에 저장한 뒤, `Collections.sort()`를 사용하여 정렬하고 리스트의 첫 번째와 마지막 원소를 출력하는 방법도 좋은 풀이이다. 이 문제에서는 N이 작아 성능 차이가 거의 없다.

- **성능 분석**:

  - **시간 복잡도**: $O(N \log N)$
  - **공간 복잡도**: $O(N)$

- **기억할 핵심 코드**:

```java
// 가장 나이 어린 학생을 찾기 위한 내림차순 PriorityQueue
PriorityQueue<Student> young = new PriorityQueue<>((s1, s2) -> {
    if(s1.year == s2.year){
        if(s1.month == s2.month){
            return Integer.compare(s2.day, s1.day);
        }
        return Integer.compare(s2.month, s1.month);
    }
    return Integer.compare(s2.year, s1.year);
});
```

---

### [20437] 문자열 게임 2

- **티어**: Gold V
- **문제 링크**: https://www.acmicpc.net/problem/20437

- **핵심 목표**:

  - 어떤 문자를 정확히 K개 포함하는 (3) 가장 짧은 연속 문자열과 (4) 가장 긴 연속 문자열의 길이를 찾는다.

- **접근 전략 (Why)**:

  - 먼저 각 문자가 문자열의 어느 위치에 나타나는지 알아야 K개를 포함하는 길이를 쉽게 계산할 수 있다. **`HashMap<Character, List<Integer>>`**을 사용하여 각 문자의 인덱스 목록을 저장하는 전처리를 수행한다($O(N)$).
  - 그 후, 각 문자의 인덱스 리스트를 순회하며, `K`개씩 묶어(`list.get(j)` 부터 `list.get(j + K - 1)`까지) 그 길이를 계산하고 최솟값/최댓값을 갱신한다. 이는 슬라이딩 윈도우와 유사한 아이디어다.

- **주요 개념**:

  - `HashMap`, 슬라이딩 윈도우

- **실수 포인트 / 함정**:

  - 문제의 조건 3(가장 짧은 문자열)과 4(가장 긴 문자열)를 모두 충족해야 하므로, min과 max 변수를 동시에 관리해야 한다.
  - 어떤 문자가 K개 미만으로 나타나는 경우는 계산 대상에서 제외해야 한다. `if (nowList.size() < K) continue;` 와 같은 예외 처리가 필요하다.

- **시도했으나 버린 접근**:

  - 전체 문자열을 이중 `for`문으로 순회하며 모든 부분 문자열을 만들고, 각 부분 문자열이 조건을 만족하는지 매번 `HashMap`으로 세는 접근. $O(N^2)$ 이상의 복잡도로 시간 초과.

- **성능 분석**:

  - **시간 복잡도**: $O(N)$ (N은 문자열의 길이)
  - **공간 복잡도**: $O(N)$

- **기억할 핵심 코드**:

```java
// 1. 각 문자의 인덱스 위치를 HashMap에 저장
HashMap<Character, List<Integer>> map = new HashMap<>();
for(int i = 0; i < W.length; i++){
    List<Integer> now = map.getOrDefault(W[i], new ArrayList<>());
    now.add(i);
    map.put(W[i],now);
}

// 2. 각 문자별로 K개를 묶어 길이 계산
List<Integer> nowList = map.getOrDefault(now, new ArrayList<>());
if(nowList.size() < K) continue;
for(int j = 0; j < nowList.size() - K + 1; j++){
    int left = j;
    int right = j + K - 1;
    // K개의 문자를 포함하는 실제 문자열 길이 계산
    int nowLength = nowList.get(right) - nowList.get(left) + 1;
    min = Math.min(min, nowLength);
    max = Math.max(max, nowLength);
}
```

---

## 2. 오늘의 정리 (주요 개념 학습)

### [슬라이딩 윈도우와 HashMap을 활용한 문자열 문제]

- **핵심아이디어**:

  - **슬라이딩 윈도우**와 **투 포인터**는 '연속된 부분 배열/문자열'과 관련된 문제를 선형 시간($O(N)$)으로 최적화하는 핵심 기법이다. 포인터를 이동시키며 상태를 갱신하는 방식으로 불필요한 중복 계산을 피한다.
  - **HashMap**은 데이터의 빈도, 위치 등 필요한 정보를 미리 계산하고 저장(전처리)하여, 이후의 탐색 및 계산 과정을 매우 효율적으로 만들어준다.

- **판단기준**:

  1.  **연속된** 구간의 합/개수/조건 등을 묻는가? -> **슬라이딩 윈도우** 또는 **투 포인터**를 최우선 고려.
  2.  문자열 내 특정 문자의 **개수**나 **위치 정보**가 중요한가? -> `HashMap`으로 관련 정보를 전처리하는 것을 고려.
  3.  **회문** 또는 **대칭** 구조를 확인해야 하는가? -> 양 끝에서 시작하는 **투 포인터**가 정석.

- **연계 문제 / 키워드**:

  - 슬라이딩 윈도우: 12891(DNA 비밀번호), 21921(블로그)
  - 투 포인터: 2018(수들의 합 5), 1253(좋다), 1806(부분합)
  - HashMap 활용: 1302(베스트셀러), 7785(회사에 있는 사람)
