# 2026년 01월 23일 SQL 스터디 노트

오늘 해결한 문제들을 기반으로 공부하면 좋을 주요 개념들을 정리합니다.

---

## 1. 문제 풀이 요약

### [대장균의 크기에 따라 분류하기 1] (Lv. 3)

- **핵심**:
  - 대장균의 크기(SIZE_OF_COLONY)에 따라 'LOW', 'MEDIUM', 'HIGH' 등급을 부여한다.

- **접근 전략**:
  - `SELECT` 절에서 `CASE` 문을 사용하여 `SIZE_OF_COLONY` 값의 범위에 따라 각기 다른 문자열 값을 반환하도록 조건을 분기한다.

- **주요 개념**:
  - `CASE WHEN ... THEN ... ELSE ... END`

- **실수 포인트 / 주의사항**:
  - `CASE` 문의 조건은 순차적으로 평가되므로, 범위가 작은 조건부터 순서대로 작성해야 한다. (`<= 100` -> `<= 1000`)

- **대안 접근**:
  - 이 문제는 `CASE` 문이 가장 직관적이고 표준적인 풀이 방법이다.

- **내 코드**:
```sql
SELECT
    ID,
    CASE 
        WHEN SIZE_OF_COLONY <= 100 THEN 'LOW'
        WHEN SIZE_OF_COLONY <= 1000 THEN 'MEDIUM'
        ELSE 'HIGH'
    END AS SIZE
FROM ECOLI_DATA 
ORDER BY ID ASC;
```

### [대장균들의 자식의 수 구하기] (Lv. 3)

- **핵심**:
  - 각 대장균(부모)이 몇 개의 자식을 가지고 있는지 집계한다.

- **접근 전략**:
  - 메인 쿼리에서 `ECOLI_DATA`를 부모 테이블로 조회하며, `SELECT` 절에 스칼라 서브쿼리를 사용한다.
  - 이 서브쿼리는 메인 쿼리의 `parent.ID`를 받아, 자식 테이블에서 `PARENT_ID`가 일치하는 레코드의 수(`COUNT(*)`)를 센다.

- **주요 개념**:
  - 스칼라 서브쿼리(Scalar Subquery), 상관 서브쿼리(Correlated Subquery)

- **실수 포인트 / 주의사항**:
  - 서브쿼리의 `WHERE` 절에서 `child.PARENT_ID = parent.ID` 와 같이 메인 쿼리의 컬럼과 정확하게 연결(상관관계)시켜야 각 부모에 맞는 자식 수를 계산할 수 있다.

- **대안 접근**:
  - `ECOLI_DATA`를 자기 자신에게 `LEFT JOIN` 한 후, `PARENT_ID`로 `GROUP BY` 하여 `COUNT(child.ID)`를 계산하는 방법도 가능하다. 대용량 데이터에서는 이 방식이 더 효율적일 수 있다.

- **내 코드**:
```sql
SELECT 
    parent.ID,
    (SELECT COUNT(*) FROM ECOLI_DATA child WHERE child.PARENT_ID = parent.ID) 
    AS CHILD_COUNT
FROM ECOLI_DATA parent
ORDER BY parent.ID ASC;
```

### [부모의 형질을 모두 가지는 대장균 찾기] (Lv. 2)

- **핵심**:
  - 자식 대장균의 형질(`GENOTYPE`)이 부모의 형질을 모두 포함하는 경우를 찾는다.

- **접근 전략**:
  - `ECOLI_DATA` 테이블을 자기 자신에게 `INNER JOIN` 하여 부모-자식 관계를 연결한다.
  - `WHERE` 절에서 비트 연산자 `&`를 사용한다. `(자식 & 부모) = 부모`는 자식이 부모의 모든 비트(형질)를 가지고 있음을 의미한다.

- **주요 개념**:
  - `INNER JOIN` (Self Join), 비트 연산자 `&` (Bitwise AND)

- **실수 포인트 / 주의사항**:
  - 비트마스크 개념을 모르면 접근이 어렵다. `(A & B) = B`는 "A가 B의 모든 속성을 포함한다"는 의미의 중요한 비트 연산 패턴이다.

- **대안 접근**:
  - 비트 연산을 사용하지 않으려면 `BIN()` 함수로 2진수 문자열로 변환 후, 문자열 연산을 해야 하므로 매우 복잡하고 비효율적이다.

- **내 코드**:
```sql
SELECT 
    child.ID,
    child.GENOTYPE AS GENOTYPE,
    parent.GENOTYPE AS PARENT_GENOTYPE
FROM ECOLI_DATA child
INNER JOIN ECOLI_DATA parent ON child.PARENT_ID = parent.ID
WHERE (child.GENOTYPE & parent.GENOTYPE) = parent.GENOTYPE
ORDER BY child.ID ASC;
```

### [조건에 맞는 개발자 찾기] (Lv. 2)

- **핵심**:
  - 보유 기술 스택에 'Python' 또는 'C#'이 포함된 개발자를 찾는다.

- **접근 전략**:
  - `SKILLCODES` 테이블에서 'Python'과 'C#'의 `CODE` 값을 `SUM`하여 필요한 기술 스택의 비트마스크 값을 만든다 (서브쿼리 사용).
  - `WHERE` 절에서 개발자의 `SKILL_CODE`와 위에서 만든 비트마스크 값을 `&` (AND) 연산하여, 결과가 0이 아니면 해당 기술 중 하나 이상을 보유한 것으로 판단한다.

- **주요 개념**:
  - 비트 연산자 `&`, 서브쿼리

- **실수 포인트 / 주의사항**:
  - 여러 기술 중 하나라도 포함되는지 확인할 때는 `(SKILL_CODE & MASK) > 0` 또는 `(SKILL_CODE & MASK) != 0`을 사용한다.
  - 모든 기술을 포함하는지 확인할 때는 `(SKILL_CODE & MASK) = MASK`를 사용한다. 둘의 차이를 명확히 알아야 한다.

- **대안 접근**:
  - `JOIN`과 `HAVING`을 사용하는 복잡한 방법도 가능하나, 비트마스크가 가장 효율적이고 의도가 명확하다.

- **내 코드**:
```sql
SELECT 
    ID,
    EMAIL,
    FIRST_NAME,
    LAST_NAME
FROM DEVELOPERS
WHERE 
    SKILL_CODE & (SELECT SUM(CODE) FROM SKILLCODES WHERE NAME IN ('Python', 'C#'))
ORDER BY ID ASC;
```

---
*이외 9개의 Level 1 문제는 기본적인 `SELECT`, `WHERE`, `ORDER BY`, `LIMIT`, `COUNT` 등의 구문을 사용하여 해결되었으므로 핵심 문제 위주로 요약했습니다.*
---

## 2. 주요 개념 및 심화 학습 포인트

오늘 풀이에서 중요했거나, 추후 다시 정리할 가치가 있는 개념을 기록합니다.

### [핵심 개념: 비트마스크(Bitmask)와 비트 연산자(&)]

- **개념**:
  - 하나의 정수(Integer)에 여러 개의 상태(flag)를 비트(bit) 단위로 저장하고, 비트 연산자를 통해 제어하는 기법.
  - 예를 들어 1(2¹), 2(2²), 4(2³), 8(2⁴)... 각 자릿수가 특정 스킬 하나를 의미하도록 설계할 수 있다.

- **언제 사용하는가?**:
  - '조건에 맞는 개발자 찾기', '특정 형질을 가지는 대장균 찾기' 처럼, 하나의 컬럼에 여러 속성(스킬, 옵션, 형질)의 포함 여부를 저장해야 할 때 유용하다.
  - 정규화된 테이블로 관리하기에는 부담스러운 다대다 관계를 간단히 표현할 수 있다.

- **쿼리 관점 포인트**:
  - **`특정 속성 포함 여부 확인`**: `(COLUMN & 속성값) > 0`
    - 예: `(SKILL_CODE & 256) > 0` -> Python 스킬이 있는가?
  - **`여러 속성 중 하나라도 포함하는지 확인`**: `(COLUMN & (속성1+속성2)) > 0`
    - 예: `(SKILL_CODE & (256+1024)) > 0` -> Python 또는 C# 스킬이 있는가?
  - **`여러 속성을 모두 포함하는지 확인`**: `(COLUMN & (속성1+속성2)) = (속성1+속성2)`
    - 예: `(child.GENOTYPE & parent.GENOTYPE) = parent.GENOTYPE` -> 자식이 부모의 모든 형질을 가졌는가?

- **비교 / 확장**:
  - `FIND_IN_SET()`이나 `LIKE` 연산은 문자열 기반이라 비트 연산보다 훨씬 느리고 인덱스를 활용하기 어렵다.
  - 정규화된 별도의 테이블(e.g., `DEVELOPER_SKILLS`)로 관리하는 것이 정석이지만, 간단한 속성 조회는 비트마스크가 성능상 매우 유리하다.

- **관련 문제**:
  - [조건에 맞는 개발자 찾기], [부모의 형질을 모두 가지는 대장균 찾기], [특정 형질을 가지는 대장균 찾기]

### [핵심 개념: 스칼라 서브쿼리 (Scalar Subquery)]

- **개념**:
  - `SELECT`, `WHERE`, `CASE` 문 등에서 단일 값(하나의 행, 하나의 컬럼)을 반환하는 서브쿼리.
  - 메인 쿼리의 각 행에 대해 독립적으로 실행되어 값을 반환한다.

- **언제 사용하는가?**:
  - '대장균들의 자식의 수 구하기'처럼, 메인 쿼리의 각 행과 연관된 다른 테이블의 집계 값(COUNT, SUM, AVG 등)을 가져와야 할 때.

- **쿼리 관점 포인트**:
  - `SELECT` 절에 사용하면, 메인 쿼리의 행 수만큼 서브쿼리가 반복 실행되므로 성능 저하의 원인이 될 수 있다.
  - `JOIN`으로 해결할 수 있다면, 옵티마이저가 더 효율적으로 처리할 수 있는 `JOIN` 방식이 일반적으로 성능이 더 좋다.

- **비교 / 확장**:
  - **`JOIN` + `GROUP BY`**: 여러 테이블을 먼저 합치고 그룹화하여 집계. 데이터가 클 경우 스칼라 서브쿼리보다 효율적.
  - **스칼라 서브쿼리**: 쿼리가 직관적이고 간결해지지만, 행별로 실행되는 특성 때문에 대용량 데이터 처리 시 주의 필요.

- **관련 문제**:
  - [대장균들의 자식의 수 구하기]

### [핵심 개념: CASE 문]

- **개념**:
  - `IF-THEN-ELSE` 논리를 SQL 쿼리 내에서 구현하는 표준 구문.
  - 특정 컬럼의 값이나 조건에 따라 결과를 동적으로 반환할 수 있다.

- **언제 사용하는가?**:
  - '대장균의 크기에 따라 분류하기 1'처럼, 특정 값의 범위(Range)에 따라 데이터를 여러 그룹으로 분류(Bucketing)하거나 등급을 매길 때.
  - 코드 값을 실제 의미(e.g., 'M' -> 'Male', 'F' -> 'Female')로 변환하여 출력할 때.

- **쿼리 관점 포인트**:
  - `WHEN` 조건은 순서대로 평가되므로, 더 구체적이거나 작은 범위의 조건을 먼저 작성해야 한다.
  - `ELSE` 구문을 생략하면 모든 조건에 맞지 않는 경우 `NULL`이 반환된다.

- **비교 / 확장**:
  - `IF(condition, true_val, false_val)`: MySQL 등 특정 DBMS에서 지원하는 함수로, 2가지 경우로만 분기할 때 `CASE`문보다 간결하게 사용할 수 있다.
  - 3가지 이상의 복잡한 조건 분기는 `CASE`문을 사용하는 것이 표준적이고 가독성이 좋다.

- **관련 문제**:
  - [대장균의 크기에 따라 분류하기 1]
