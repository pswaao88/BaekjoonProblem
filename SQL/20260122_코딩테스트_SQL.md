# 2026년 01월 22일 SQL 스터디 노트

오늘 해결한 문제들을 기반으로 공부하면 좋을 주요 개념들을 정리합니다.

---

## 1. 문제 풀이 요약

### [업그레이드 된 아이템 구하기] (Lv. 2)

- **핵심**:
  - 'RARE' 등급의 아이템을 업그레이드하여 얻을 수 있는 모든 아이템을 조회한다.

- **접근 전략**:
  1. **(CTE 1)** `ITEM_INFO`에서 `RARITY`가 'RARE'인 아이템들의 ID를 먼저 선별한다.
  2. **(CTE 2)** `ITEM_TREE`와 첫 번째 CTE를 조인하여, 'RARE' 아이템을 부모로 가지는 자식 아이템들의 ID를 찾는다.
  3. **(Main Query)** 두 번째 CTE와 `ITEM_INFO`를 다시 조인하여, 최종적으로 업그레이드된 아이템들의 상세 정보를 조회한다.
  4. **(ORDER BY)** 결과를 아이템 ID 기준 내림차순으로 정렬한다.

- **주요 개념**:
  - `WITH` (CTE), `INNER JOIN`

- **실수 포인트 / 주의사항**:
  - `ITEM_TREE`의 `PARENT_ITEM_ID`가 'RARE' 등급 아이템의 ID와 일치하는 조건을 정확하게 연결하는 것이 중요하다.
  - 여러 단계의 조인이 필요하므로, CTE를 사용하여 각 단계를 명확히 구분하는 것이 가독성에 유리하다.

- **대안 접근**:
  - JOIN 절 안에 서브쿼리를 직접 작성하여 CTE를 대체할 수 있으나, 쿼리가 복잡해지고 가독성이 저하될 수 있다.

- **내 코드**:
```sql
WITH RARE AS (
    SELECT info.ITEM_ID FROM ITEM_INFO info 
    WHERE info.RARITY = 'RARE'
), RARE_UPGRADE AS (
    SELECT it.ITEM_ID FROM ITEM_TREE it
    INNER JOIN 
    RARE r ON r.ITEM_ID = it.PARENT_ITEM_ID
    GROUP BY it.ITEM_ID
)
SELECT i.ITEM_ID, i.ITEM_NAME, i.RARITY
FROM ITEM_INFO i 
INNER JOIN RARE_UPGRADE ru ON i.ITEM_ID = ru.ITEM_ID
ORDER BY i.ITEM_ID DESC;
```

### [오프라인/온라인 판매 데이터 통합하기] (Lv. 4)

- **핵심**:
  - 두 개의 다른 판매 테이블(온라인/오프라인)을 하나로 통합하고, 특정 기간의 데이터를 정렬하여 조회한다.

- **접근 전략**:
  1. **(CTE)** `UNION ALL`을 사용하여 `ONLINE_SALE`과 `OFFLINE_SALE` 테이블의 데이터를 합친다.
  2. 이 때 `OFFLINE_SALE` 테이블에는 `USER_ID`가 없으므로, `NULL`로 값을 채워 두 테이블의 스키마를 일치시킨다.
  3. **(Main Query)** 통합된 CTE 결과에서 `SALES_DATE`가 '2022-03'인 데이터만 필터링한다.
  4. **(ORDER BY)** 문제의 요구사항에 따라 판매일, 상품 ID, 사용자 ID 순으로 오름차순 정렬한다.

- **주요 개념**:
  - `UNION ALL`, `WITH` (CTE), `DATE_FORMAT`, `NULL` 처리

- **실수 포인트 / 주의사항**:
  - `UNION`은 중복을 제거하는 과정에서 성능 저하가 발생할 수 있으므로, 모든 데이터를 포함해야 할 경우 `UNION ALL`을 사용하는 것이 효율적이다.
  - `UNION` 계열 연산 시, 각 `SELECT` 문의 컬럼 수와 데이터 타입이 일치해야 하며, 컬럼의 의미에 맞게 `NULL` 값을 채워주는 것이 중요하다.

- **대안 접근**:
  - CTE 대신 `FROM` 절에 `UNION ALL`로 묶인 서브쿼리를 직접 사용할 수도 있지만, 쿼리가 길어질 경우 CTE 방식이 더 명확하다.

- **내 코드**:
```sql
WITH TOTAL AS (
    SELECT 
        DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE, 
        PRODUCT_ID, 
        USER_ID, 
        SALES_AMOUNT
    FROM ONLINE_SALE

    UNION ALL

    SELECT 
        DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE, 
        PRODUCT_ID, NULL AS USER_ID, 
        SALES_AMOUNT
    FROM OFFLINE_SALE
)
SELECT * 
FROM TOTAL 
WHERE DATE_FORMAT(SALES_DATE, '%Y-%m') = '2022-03'
ORDER BY 
    SALES_DATE ASC, 
    PRODUCT_ID ASC, 
    USER_ID ASC;
```

### [조건에 부합하는 중고거래 댓글 조회하기] (Lv. 1)

- **핵심**:
  - 특정 기간에 작성된 게시글에 달린 모든 댓글 정보를 조회한다.

- **접근 전략**:
  1. **(JOIN)** `USED_GOODS_BOARD`와 `USED_GOODS_REPLY` 테이블을 `BOARD_ID` 기준으로 `INNER JOIN`하여 게시글과 댓글을 연결한다.
  2. **(WHERE)** `DATE_FORMAT` 함수를 사용하여 게시글(`b`)의 작성일이 '2022-10'인 데이터만 필터링한다.
  3. **(SELECT)** 조회할 컬럼들을 선택하고, 댓글의 `CREATED_DATE` 형식을 'YYYY-MM-DD'로 맞춘다.
  4. **(ORDER BY)** 결과를 댓글 작성일, 게시글 제목 순으로 오름차순 정렬한다.

- **주요 개념**:
  - `INNER JOIN`, `WHERE`, `DATE_FORMAT`, `ORDER BY`

- **실수 포인트 / 주의사항**:
  - 필터링 기준이 댓글 작성일이 아닌 **게시글 작성일**이라는 점에 유의해야 한다.
  - 정렬 순서가 댓글 작성일이 먼저이고, 그 다음이 게시글 제목이라는 점을 놓치지 말아야 한다.

- **대안 접근**:
  - `WHERE DATE_FORMAT(b.CREATED_DATE,'%Y-%m') = '2022-10'` 대신 `WHERE b.CREATED_DATE BETWEEN '2022-10-01' AND '2022-10-31 23:59:59'` 와 같이 `BETWEEN`을 사용할 수도 있다.

- **내 코드**:
```sql
SELECT 
    b.TITLE, 
    b.BOARD_ID, 
    r.REPLY_ID, 
    r.WRITER_ID, 
    r.CONTENTS, 
    DATE_FORMAT(r.CREATED_DATE, '%Y-%m-%d') AS CREATED_DATE
FROM USED_GOODS_BOARD b
INNER JOIN USED_GOODS_REPLY r ON b.BOARD_ID = r.BOARD_ID 
WHERE DATE_FORMAT(b.CREATED_DATE,'%Y-%m') = '2022-10'
ORDER BY CREATED_DATE ASC, b.TITLE ASC;
```

### [어린 동물 찾기], [아픈 동물 찾기], [역순 정렬하기] (Lv. 1)

- **핵심**:
  - 간단한 조건(`WHERE`)과 정렬(`ORDER BY`)을 사용하여 원하는 데이터를 조회하는 기본적인 문제들이다.

- **접근 전략**:
  - `SELECT`로 원하는 컬럼을 지정하고, `FROM`으로 테이블을 선택한다.
  - `WHERE` 절을 사용하여 `INTAKE_CONDITION`이 특정 값이거나 특정 값이 아닌 경우를 필터링한다.
  - `ORDER BY` 절과 `DESC` 키워드를 사용하여 결과를 내림차순으로 정렬한다.

- **주요 개념**:
  - `SELECT`, `FROM`, `WHERE`, `ORDER BY`, `DESC`, `NOT`

- **내 코드**:
```sql
-- 어린 동물 찾기
SELECT ANIMAL_ID, NAME
FROM ANIMAL_INS
WHERE NOT INTAKE_CONDITION = 'AGED'
ORDER BY ANIMAL_ID;

-- 아픈 동물 찾기
SELECT ANIMAL_ID, NAME 
FROM ANIMAL_INS 
WHERE INTAKE_CONDITION = 'Sick';

-- 역순 정렬하기
SELECT NAME, DATETIME FROM ANIMAL_INS ORDER BY ANIMAL_ID DESC;
```

## 2. 주요 개념 및 심화 학습 포인트

오늘 풀이에서 중요했거나, 추후 다시 정리할 가치가 있는 개념을 기록합니다.

### [핵심 개념: CTE (Common Table Expression)]

- **개념**:
  - `WITH` 키워드를 사용하여 정의하는 임시 결과 집합. 복잡한 쿼리를 논리적인 단계로 나누어 가독성을 높이고, 쿼리 내에서 여러 번 재사용할 수 있게 해준다.

- **언제 사용하는가?**:
  - '업그레이드 된 아이템 구하기'처럼 여러 단계의 데이터 가공 및 조인이 필요할 때.
  - '오프라인/온라인 판매 데이터 통합하기'처럼 서브쿼리가 너무 길어지거나 복잡해질 때.

- **쿼리 관점 포인트**:
  - 메인 쿼리를 실행하기 전에 필요한 '재료'를 미리 준비하는 과정으로 생각하면 편하다.
  - 각 CTE는 독립적인 `SELECT` 문으로, 이전 CTE나 테이블을 참조하여 새로운 임시 테이블을 만든다.

- **비교 / 확장**:
  - **서브쿼리**: 보통 일회성으로 사용되며, 쿼리 구조가 복잡해지면 가독성이 떨어진다.
  - **CTE**: 이름을 가질 수 있어 재사용이 가능하고, 쿼리의 논리적 흐름을 명확하게 보여준다. 재귀(Recursive) CTE를 사용하면 계층 구조 데이터도 쉽게 다룰 수 있다.

- **관련 문제**:
  - [업그레이드 된 아이템 구하기], [오프라인/온라인 판매 데이터 통합하기]

### [핵심 개념: UNION vs UNION ALL]

- **개념**:
  - 두 개 이상의 `SELECT` 문의 결과를 하나의 결과 집합으로 결합한다.

- **언제 사용하는가?**:
  - '오프라인/온라인 판매 데이터 통합하기'처럼 구조는 같지만 서로 다른 테이블에 저장된 데이터를 합쳐서 분석해야 할 때.

- **쿼리 관점 포인트**:
  - `UNION`과 `UNION ALL`로 결합될 각 `SELECT` 문은 동일한 수의 컬럼을 가져야 하며, 대응되는 컬럼들은 유사한 데이터 타입을 가져야 한다.

- **비교 / 확장**:
  - **`UNION`**: 결과를 합친 후 **중복된 행을 제거**한다. 중복 제거 과정에서 정렬이 발생하므로 `UNION ALL`보다 느리다.
  - **`UNION ALL`**: 중복을 제거하지 않고 **그대로 합친다**. 단순히 데이터를 합치기만 하면 될 경우 성능상 이점이 있다.
  - 따라서, 중복될 가능성이 없거나 중복이 허용되는 상황이라면 `UNION ALL`을 사용하는 것이 좋다.

- **관련 문제**:
  - [오프라인/온라인 판매 데이터 통합하기]
