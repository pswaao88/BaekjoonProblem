# 2026년 1월 19일 알고리즘 스터디 노트

오늘 해결한 문제들을 기반으로 공부하면 좋을 주요 개념들을 정리합니다.

---

## 1. 문제 풀이 요약

### 평균 일일 대여 요금 구하기 (Lv.1)

- **핵심**: 특정 차종('SUV')의 평균 일일 대여 요금을 계산하는 문제.
- **주요 개념**: `AVG`, `ROUND`, `GROUP BY`, `HAVING`
- **내 코드**:
  ```sql
  // 여기에 문제 풀이 코드를 붙여넣으세요.
  ```

### 대장균의 크기에 따라 분류하기 2 (Lv.3)

- **핵심**: 대장균 크기의 상대적 순위를 매겨 등급(CRITICAL, HIGH 등)을 부여하는 문제.
- **주요 개념**: CTE (`WITH`), 윈도우 함수 (`PERCENT_RANK`, `OVER`), `CASE`
- **내 코드**:
  ```sql
  // 여기에 문제 풀이 코드를 붙여넣으세요.
  ```

### 특정 세대의 대장균 찾기 (Lv.4)

- **핵심**: 계층적 구조를 가진 대장균 데이터에서 특정 세대(3세대)에 속하는 개체를 찾는 문제.
- **주요 개념**: 재귀 CTE (`WITH RECURSIVE`), `UNION ALL`, `INNER JOIN`
- **내 코드**:
  ```sql
  // 여기에 문제 풀이 코드를 붙여넣으세요.
  ```

### 멸종위기의 대장균 찾기 (Lv.5)

- **핵심**: 각 세대별로 자식이 없는 대장균(leaf node)의 수를 세는 문제.
- **주요 개념**: 재귀 CTE, `NOT EXISTS` (서브쿼리), `GROUP BY`, `COUNT`
- **내 코드**:
  ```sql
  // 여기에 문제 풀이 코드를 붙여넣으세요.
  ```

---

## 2. 주요 개념 및 심화 학습 포인트

오늘 풀이에서 중요했거나, 비슷한 함수 설명, 추가적으로 학습이 필요한 개념, 같은 문제 다른 풀이 들을 정리합니다.

### 핵심 개념 1: 재귀 CTE (Recursive Common Table Expressions)

- **개념**: `WITH RECURSIVE` 키워드를 사용하여 계층 구조(부모-자식 관계) 데이터를 효과적으로 탐색하는 기능입니다.
- **언제 사용하는가?**: 조직도, 메뉴 구조, 가계도 같은 계층적 데이터를 다룰 때 필수적입니다.
- **사용 예시**: 
  ```sql
  -- WITH RECURSIVE cte AS (
  --     -- 1. Base Member (기준점): 재귀의 시작점이 되는 쿼리
  --     SELECT ... FROM ... WHERE PARENT_ID IS NULL
  --     UNION ALL
  --     -- 2. Recursive Member (재귀 부분): 이전 결과를 참조하여 자식/부모를 찾아가는 쿼리
  --     SELECT ... FROM ... JOIN cte ON ...
  -- )
  -- SELECT * FROM cte;
  ```
- **학습 포인트**: 재귀 쿼리는 개념이 복잡하므로, 다른 예제들을 통해 반복적으로 연습하여 완전히 자신의 것으로 만드는 것을 추천합니다.
- **관련 문제**: `특정 세대의 대장균 찾기`, `멸종위기의 대장균 찾기`

### 핵심 개념 2: 윈도우 함수 (Window Functions)

- **개념**: 행의 집합(Window) 내에서 각 행에 대한 계산을 수행하는 함수입니다. `GROUP BY`와 달리 행을 하나로 합치지 않고, 각 행의 원래 위치를 유지하면서 순위, 합계, 평균 등을 계산할 수 있습니다.
- **언제 사용하는가?**: 데이터를 그룹으로 묶지 않고 순위, 백분위, 누적 합계 등을 계산해야 할 때 유용합니다.
- **사용 예시**:
  ```sql
  -- PERCENT_RANK() OVER (ORDER BY SIZE_OF_COLONY DESC)
  -- RANK() OVER (PARTITION BY CAR_TYPE ORDER BY DAILY_FEE)
  ```
- **학습 포인트**: `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()`, `NTILE()` 등 다양한 순위 관련 윈도우 함수들의 차이점을 비교하고 언제 사용해야 하는지 학습해보세요.
- **관련 문제**: `대장균의 크기에 따라 분류하기 2`

### 핵심 개념 3: NOT EXISTS

- **개념**: 서브쿼리에서 `NOT EXISTS`를 사용하여 메인 쿼리의 행과 관련된 행이 서브쿼리에 존재하지 않는 경우 `TRUE`를 반환합니다.
- **언제 사용하는가?**: '자식이 없는 부모 찾기', '주문 이력 없는 고객 찾기' 등 특정 조건에 맞는 데이터가 존재하지 않는 경우를 필터링할 때 매우 유용합니다.
- **사용 예시**:
  ```sql
  -- 자식이 없는 개체(Leaf Node) 찾기
  -- WHERE NOT EXISTS (SELECT 1 FROM ECOLI_DATA e WHERE e.PARENT_ID = t.ID)
  ```
- **학습 포인트**: `NOT IN`과의 성능 및 `NULL` 값 처리 차이를 비교해보세요. 일반적으로 대용량 데이터에서는 `NOT EXISTS`가 더 효율적입니다.
- **관련 문제**: `멸종위기의 대장균 찾기`

### 핵심 개념 4: HAVING vs WHERE

- **개념**: `WHERE`는 `GROUP BY` 실행 *전*에 개별 행을 필터링하고, `HAVING`은 `GROUP BY` 실행 *후*에 집계된 그룹 결과를 필터링합니다.
- **언제 사용하는가?**: `WHERE`는 집계 전 원본 데이터를 필터링할 때, `HAVING`은 집계 함수(`SUM`, `AVG` 등)의 결과를 기반으로 그룹을 필터링할 때 사용합니다.
- **사용 예시**:
  ```sql
  -- WHERE: 집계 전 필터링 (보다 효율적)
  -- SELECT ... FROM ... WHERE CAR_TYPE = 'SUV' GROUP BY ...
  
  -- HAVING: 집계 후 필터링
  -- SELECT ... FROM ... GROUP BY CAR_TYPE HAVING AVG(DAILY_FEE) > 100
  ```
- **학습 포인트**: 성능을 위해 가능하다면 `WHERE` 절에서 미리 데이터를 필터링하는 것이 `GROUP BY`할 데이터 양을 줄여주므로 성능상 더 유리합니다.
- **관련 문제**: `평균 일일 대여 요금 구하기`

---

## 3. 오늘의 회고

- **잘한 점**: [오늘 학습/풀이 과정에서 만족스러웠던 부분]
- **어려웠던 점 / 아쉬운 점**: [어려웠거나, 더 나은 방법이 있었을 것 같은 부분]
- **다음에 시도해볼 것**: LeetCode의 SQL 문제 중 'Hard' 난이도 문제들을 풀어보시면 재귀 쿼리와 윈도우 함수를 연습하기에 좋습니다.

오늘도 수고하셨습니다!