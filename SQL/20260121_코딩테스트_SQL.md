# 2026년 01월 21일 SQL 스터디 노트

오늘 해결한 문제들을 기반으로 공부하면 좋을 주요 개념들을 정리합니다.

---

## 1. 문제 풀이 요약

### [재구매가 일어난 상품과 회원 리스트 구하기] (Lv. 2)

- **핵심**:
  - 동일한 사용자가 동일한 상품을 2번 이상 구매한 모든 기록을 조회한다.

- **접근 전략**:
  1.  **FROM `ONLINE_SALE`**: 먼저 온라인 판매 기록 전체를 대상으로 한다.
  2.  **GROUP BY `USER_ID`, `PRODUCT_ID`**: 사용자 ID와 상품 ID를 기준으로 그룹화하여, 특정 사용자가 특정 상품을 몇 번 구매했는지 집계할 준비를 한다.
  3.  **SELECT `..., COUNT(*)`**: 위 그룹을 기반으로 구매 횟수를 계산한다. 이 중간 결과를 `WITH` 절(CTE)로 만들어 가독성을 높였다.
  4.  **WHERE `TOTAL >= 2`**: CTE 결과 중에서, 집계된 구매 횟수가 2 이상인 경우만 필터링한다.
  5.  **ORDER BY**: 최종 결과를 요구사항에 맞게 정렬한다.

- **주요 개념**:
  - `GROUP BY`, `COUNT()`, `WITH` (CTE), `HAVING`

- **실수 포인트 / 주의사항**:
  - `GROUP BY`로 집계한 결과(`COUNT(*)`)는 `WHERE` 절에서 직접 필터링할 수 없다. `WHERE`는 그룹화 이전에 개별 행에 대해 동작하기 때문이다.
  - 이 코드처럼 CTE를 사용하거나, `HAVING` 절을 사용해야 한다.

- **대안 접근**:
  - CTE 대신 `HAVING` 절을 사용하면 쿼리를 더 간결하게 작성할 수 있다.
  ```sql
  SELECT USER_ID, PRODUCT_ID
  FROM ONLINE_SALE
  GROUP BY USER_ID, PRODUCT_ID
  HAVING COUNT(*) >= 2;
  ```

- **내 코드**:
```sql
WITH RESALE AS (
    SELECT 
        USER_ID, 
        PRODUCT_ID, 
        COUNT(*) AS TOTAL
    FROM ONLINE_SALE 
    GROUP BY USER_ID, PRODUCT_ID 
)

SELECT 
    USER_ID, 
    PRODUCT_ID 
FROM RESALE 
WHERE TOTAL >= 2
ORDER BY USER_ID ASC, PRODUCT_ID DESC;
```

---

### [서울에 위치한 식당 목록 출력하기] (Lv. 4)

- **핵심**:
  - '서울'에 위치한 식당 정보와 해당 식당의 평균 리뷰 점수를 함께 조회한다.

- **접근 전략**:
  1.  **FROM `REST_INFO` INNER JOIN `REST_REVIEW`**: 식당 정보와 리뷰 정보를 `REST_ID` 기준으로 합쳐 필요한 데이터를 모두 준비한다.
  2.  **WHERE `ADDRESS LIKE '서울%'`**: 주소가 '서울'로 시작하는 식당만 필터링한다.
  3.  **GROUP BY `REST_ID`**: 식당별로 평균 점수를 내기 위해 `REST_ID`를 기준으로 그룹화한다.
  4.  **SELECT `..., ROUND(AVG(REVIEW_SCORE), 2)`**: 그룹화된 결과 내에서 평균 점수를 계산하고, `ROUND` 함수로 반올림 처리한다.
  5.  **ORDER BY `SCORE DESC, ...`**: 계산된 평균 점수(별칭 `SCORE`)를 기준으로 내림차순 정렬한다.

- **주요 개념**:
  - `INNER JOIN`, `GROUP BY`, `AVG()`, `ROUND()`, `LIKE`

- **실수 포인트 / 주의사항**:
  - 집계 함수(`AVG`)를 사용하려면 반드시 `GROUP BY` 기준이 명시되어야 한다. 그렇지 않으면 전체 데이터의 평균 하나만 계산된다.
  - `WHERE` 절의 주소 필터링 조건(`LIKE '서울%'`)이 `GROUP BY`보다 먼저 실행되어야 효율적이다.

- **대안 접근**:
  - `WHERE SUBSTRING(ADDRESS, 1, 2) = '서울'` 처럼 `SUBSTRING` 함수를 사용할 수도 있으나, `LIKE '서울%'`가 더 직관적이고 인덱스 활용에 유리할 수 있다.

- **내 코드**:
```sql
-- CTE를 사용한 이유는 쿼리의 가독성을 높이기 위함
WITH REST AS (
    SELECT 
        i.REST_ID,
        i.REST_NAME, 
        i.FOOD_TYPE, 
        i.FAVORITES,   
        i.ADDRESS, 
        r.REVIEW_SCORE
    FROM REST_INFO i
    INNER JOIN REST_REVIEW r 
    ON i.REST_ID = r.REST_ID
)

SELECT 
    REST_ID, 
    REST_NAME, 
    FOOD_TYPE, 
    FAVORITES, 
    ADDRESS, 
    ROUND(AVG(REVIEW_SCORE), 2) AS SCORE
FROM REST 
WHERE SUBSTRING(ADDRESS, 1, 2) = '서울'
GROUP BY REST_ID
ORDER BY SCORE DESC, FAVORITES DESC;
```

---

### [강원도에 위치한 생산공장 목록 출력하기] (Lv. 1)

- **핵심**:
  - 주소지가 '강원도'인 식품공장의 정보를 조회한다.

- **접근 전략**:
  1.  **FROM `FOOD_FACTORY`**: 공장 정보 테이블을 조회 대상으로 지정한다.
  2.  **WHERE `SUBSTRING_INDEX(...) = '강원도'`**: `SUBSTRING_INDEX` 함수를 사용하여 주소에서 첫 번째 공백 앞부분(시/도)을 추출하고 '강원도'와 비교하여 필터링한다.
  3.  **ORDER BY `FACTORY_ID`**: 결과를 공장 ID 순으로 정렬한다.

- **주요 개념**:
  - `WHERE`, `SUBSTRING_INDEX`, `ORDER BY`

- **실수 포인트 / 주의사항**:
  - `LEFT(ADDRESS, 3)`처럼 고정 길이로 자르면 '서울특별시'와 '경기도'처럼 이름 길이가 다른 경우를 제대로 처리할 수 없다. `LIKE` 또는 `SUBSTRING_INDEX`를 사용하는 것이 더 안정적이다.

- **대안 접근**:
  - `WHERE ADDRESS LIKE '강원도%'` 구문이 더 일반적이고 직관적인 풀이 방법이다.

- **내 코드**:
```sql
SELECT FACTORY_ID, FACTORY_NAME, ADDRESS
FROM FOOD_FACTORY WHERE SUBSTRING_INDEX(ADDRESS, ' ', 1) = '강원도'
ORDER BY FACTORY_ID;
```

---

### [3월에 태어난 여성 회원 목록 출력하기] (Lv. 2)

- **핵심**:
  - 생일이 3월인 여성 회원 중, 전화번호가 등록된 사람만 조회한다.

- **접근 전략**:
  1.  **FROM `MEMBER_PROFILE`**: 회원 정보 테이블을 조회 대상으로 한다.
  2.  **WHERE `...`**: `AND` 연산자로 3가지 조건을 모두 만족하는 행을 필터링한다.
      - `MONTH(DATE_OF_BIRTH) = 3`: `MONTH` 함수로 생일이 3월인 조건.
      - `GENDER = 'W'`: 성별이 여성인 조건.
      - `TLNO IS NOT NULL`: 전화번호가 NULL이 아닌 조건.
  3.  **SELECT `..., DATE_FORMAT(...)`**: `DATE_FORMAT` 함수를 사용하여 날짜 출력 형식을 'YYYY-MM-DD'로 맞춘다.

- **주요 개념**:
  - `WHERE`, `AND`, `MONTH()`, `DATE_FORMAT()`, `IS NOT NULL`

- **실수 포인트 / 주의사항**:
  - `NULL` 값의 존재 여부를 확인할 때는 `=` 이나 `!=` 연산자가 아니라 `IS NULL` 또는 `IS NOT NULL` 키워드를 사용해야 한다.

- **대안 접근**:
  - `WHERE DATE_FORMAT(DATE_OF_BIRTH, '%c') = '3'` 와 같이 `WHERE` 절에서 `DATE_FORMAT`을 사용할 수도 있지만, 함수로 가공된 컬럼은 인덱스를 타기 어려워 대용량 데이터에서는 성능 저하가 발생할 수 있다.

- **내 코드**:
```sql
SELECT 
    MEMBER_ID, 
    MEMBER_NAME, 
    GENDER, 
    DATE_FORMAT(DATE_OF_BIRTH, '%Y-%m-%d') AS DATE_OF_BIRTH
FROM MEMBER_PROFILE 
WHERE MONTH(DATE_OF_BIRTH) = 3 AND GENDER = 'W' AND TLNO IS NOT NULL 
ORDER BY MEMBER_ID ASC;
```

---

## 2. 주요 개념 및 심화 학습 포인트

오늘 풀이에서 중요했거나, 추후 다시 정리할 가치가 있는 개념을 기록합니다.

### [핵심 개념: GROUP BY와 집계함수]

- **개념**:
  - 특정 컬럼을 기준으로 데이터를 그룹화하고, 각 그룹에 대해 `COUNT`, `AVG`, `SUM` 같은 집계 함수를 적용하여 통계 정보를 얻기 위해 사용되었다.

- **언제 사용하는가?**:
  - '사용자별 구매 횟수', '식당별 평균 평점'처럼 특정 단위로 묶어서 통계를 내야 하는 모든 상황에서 사용된다.

- **쿼리 관점 포인트**:
  - 1. 무엇을 기준으로 묶을 것인가? (`GROUP BY` 절)
  - 2. 각 그룹에서 무엇을 계산할 것인가? (`SELECT` 절의 집계 함수)
  - 3. 그룹화된 결과 중 어떤 것을 필터링할 것인가? (`HAVING` 절)

- **비교 / 확장**:
  - `WHERE`는 그룹화 전 개별 행을 필터링하는 반면, `HAVING`은 그룹화 후의 집계 결과를 필터링한다. 성능을 위해 `WHERE`에서 최대한 거르는 것이 유리하다.
  - `GROUP BY`는 행들을 하나로 합치지만, `PARTITION BY`를 사용하는 윈도우 함수는 원본 행을 유지하면서 집계 결과를 각 행에 추가할 수 있다는 차이점이 있다.

- **관련 문제**:
  - [재구매가 일어난 상품과 회원 리스트 구하기], [서울에 위치한 식당 목록 출력하기]
