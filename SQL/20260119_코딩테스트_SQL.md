# 2026년 01월 19일 SQL 스터디 노트

오늘 해결한 문제들을 기반으로 공부하면 좋을 주요 개념들을 정리합니다.

---

## 1. 문제 풀이 요약

### [평균 일일 대여 요금 구하기] (Lv. 1)

- **핵심**:
  - 특정 차종('SUV')의 평균 일일 대여 요금을 계산

- **접근 전략**:
  - `CAR_RENTAL_COMPANY_CAR` 테이블에서 `CAR_TYPE`이 'SUV'인 차량 필터링 (WHERE)
  - `DAILY_FEE`의 평균 계산 (AVG)
  - 소수점 첫째 자리에서 반올림 (ROUND)

- **주요 개념**:
  - `AVG`, `ROUND`, `WHERE`

- **실수 포인트 / 주의사항**:
  - `GROUP BY` 없이 전체 평균을 구하는 것이므로 `HAVING`이 아닌 `WHERE`를 사용해야 함.
  - 문제의 출력 형식(컬럼명, 반올림)을 정확히 지켜야 함.

- **대안 접근**:
  - 이 문제는 매우 간단하여 특별한 대안 접근이 불필요함.

- **내 코드**:
```sql
-- 코드를 입력하세요
SELECT ROUND(AVG(DAILY_FEE)) AS AVERAGE_FEE
FROM CAR_RENTAL_COMPANY_CAR 
GROUP BY CAR_TYPE HAVING CAR_TYPE = 'SUV';
```

### [대장균의 크기에 따라 분류하기 2] (Lv. 3)

- **핵심**:
  - 전체 대장균을 크기 순으로 정렬 후, 상위 백분율에 따라 등급 부여

- **접근 전략**:
  - CTE(`WITH`)를 사용하여 `ECOLI_DATA`에 `PERCENT_RANK` 윈도우 함수를 적용한 순위(rank) 컬럼 추가
  - 메인 쿼리에서 `CASE` 문을 사용해 `rank` 값에 따라 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW' 등급 부여
  - 최종적으로 ID와 등급을 `ID` 순으로 정렬

- **주요 개념**:
  - CTE (`WITH`)
  - 윈도우 함수 (`PERCENT_RANK() OVER())`
  - `CASE` 문

- **실수 포인트 / 주의사항**:
  - `RANK()`, `DENSE_RANK()`가 아닌 `PERCENT_RANK()`를 사용해야 백분율 기준을 정확히 맞출 수 있음.
  - `OVER()` 절에 `ORDER BY SIZE_OF_COLONY DESC`를 정확히 명시해야 함.

- **대안 접근**:
  - 서브쿼리를 사용하여 CTE를 대체할 수 있으나, 가독성 면에서 CTE가 더 유리함.

- **내 코드**:
```sql
WITH ECOLI_DATA_AFTER AS 
(SELECT 
    ID, 
    PERCENT_RANK() OVER (ORDER BY SIZE_OF_COLONY DESC) AS SIZE_RANK 
FROM ECOLI_DATA)

SELECT 
    ID, 
    CASE
        WHEN SIZE_RANK <= 0.25 THEN "CRITICAL"
        WHEN SIZE_RANK <= 0.5 THEN "HIGH"
        WHEN SIZE_RANK <= 0.75 THEN "MEDIUM"
        ELSE "LOW"
    END AS COLONY_NAME
FROM ECOLI_DATA_AFTER ORDER BY ID;
```

### [특정 세대의 대장균 찾기] (Lv. 4)

- **핵심**:
  - 재귀적 관계를 가진 데이터에서 3세대 대장균의 ID 찾기

- **접근 전략**:
  - 재귀 CTE(`WITH RECURSIVE`)를 사용하여 각 대장균의 세대(generation)를 계산
  - 시작점(Base Member): 부모가 없는 1세대 대장균 조회
  - 재귀(Recursive Member): 이전 세대 결과와 `ECOLI_DATA`를 조인하여 다음 세대를 찾아감
  - 최종적으로 CTE 결과에서 `generation`이 3인 대장균의 ID만 필터링

- **주요 개념**:
  - 재귀 CTE (`WITH RECURSIVE`)
  - `UNION ALL`
  - `INNER JOIN`

- **실수 포인트 / 주의사항**:
  - 재귀 CTE의 종료 조건을 명확히 하지 않으면 무한 루프에 빠질 수 있음. (이 문제에서는 더 이상 자식이 없으면 재귀가 멈춤)
  - `UNION ALL`을 사용해야 중복 제거 없이 모든 결과를 포함할 수 있음.

- **대안 접근**:
  - 재귀를 지원하지 않는 DB 환경이라면, 부모-자식 관계를 여러 번 SELF JOIN하여 3세대를 찾아야 하므로 쿼리가 매우 복잡해짐.

- **내 코드**:
```sql
WITH RECURSIVE TREE AS (
    -- 루트 부분으로 1회만 실행
    SELECT 
        ID, 
        PARENT_ID , 
        1 AS DEPTH 
    FROM ECOLI_DATA WHERE PARENT_ID IS NULL
    -- 이 아래부터 재귀 파트
    UNION ALL
    -- root부터 시작해서 재귀 돌리기
    -- e는 자식 t가 부모의 역할
    SELECT 
        e.ID, 
        e.PARENT_ID, 
        t.DEPTH + 1
    FROM ECOLI_DATA e
    INNER JOIN 
    TREE t ON e.PARENT_ID = t.ID
)

SELECT ID FROM TREE WHERE DEPTH = 3;
```

### [멸종위기의 대장균 찾기] (Lv. 5)

- **핵심**:
  - 각 세대별로 자식이 없는 대장균(Leaf Node)의 수와 해당 세대를 출력

- **접근 전략**:
  - 재귀 CTE를 사용해 모든 대장균의 `ID`와 `세대(generation)`를 구함. (앞선 '특정 세대의 대장균 찾기'와 동일 로직)
  - 메인 쿼리에서 CTE 결과를 기반으로, `NOT EXISTS` 서브쿼리를 사용해 자식(`PARENT_ID`가 현재 ID인)이 없는 대장균만 필터링
  - 세대(`generation`) 별로 그룹화(`GROUP BY`)하여 개수(`COUNT`)를 셈
  - 세대 순으로 정렬 (`ORDER BY`)

- **주요 개념**:
  - 재귀 CTE
  - `NOT EXISTS`
  - `GROUP BY` / `COUNT`

- **실수 포인트 / 주의사항**:
  - 자식이 없는 조건을 구현할 때 `LEFT JOIN` 후 `WHERE CHILD_ID IS NULL` 패턴을 사용할 수도 있지만, `NOT EXISTS`가 의도를 더 명확하게 보여줌.
  - `GROUP BY`절에 `generation`을 명시하는 것을 잊지 말아야 함.

- **대안 접근**:
  - `NOT IN`을 사용할 수도 있으나, 서브쿼리 결과에 `NULL`이 포함될 경우 예상치 못한 결과를 낼 수 있어 `NOT EXISTS`가 더 안전함.

- **내 코드**:
```sql
WITH RECURSIVE TREE AS(
    SELECT 
        ID,
        PARENT_ID,
        1 AS GENERATION
    FROM ECOLI_DATA WHERE PARENT_ID IS NULL
    
    UNION ALL
    
    SELECT 
        e.ID, 
        e.PARENT_ID, 
        t.GENERATION + 1
    FROM ECOLI_DATA e 
    INNER JOIN TREE t ON e.PARENT_ID = t.ID
)

SELECT
COUNT(*) AS COUNT,
GENERATION
FROM TREE t 
WHERE NOT EXISTS(
    SELECT 1 
    FROM ECOLI_DATA e 
    WHERE e.PARENT_ID = t.ID
) 
GROUP BY GENERATION ORDER BY GENERATION;
```

## 2. 주요 개념 및 심화 학습 포인트

오늘 풀이에서 중요했거나, 추후 다시 정리할 가치가 있는 개념을 기록합니다.

### [핵심 개념: 재귀 CTE (Recursive Common Table Expressions)]

- **개념**:
  - 자기 자신을 참조하는 CTE로, 계층 구조 데이터를 탐색하는 데 사용됨.
  - `Base Member`(시작점)와 `Recursive Member`(반복 부분)로 구성되며 `UNION ALL`로 연결.

- **언제 사용하는가?**:
  - 조직도, 메뉴 구조, 가계도 등 부모-자식 관계가 명확한 데이터를 다룰 때.
  - '특정 세대의 대장균 찾기', '멸종위기의 대장균 찾기'처럼 세대를 거슬러 올라가거나 내려가야 할 때.

- **쿼리 관점 포인트**:
  - 재귀의 시작점(1세대, 최상위 부모 등)을 정의하는 것이 첫 단계.
  - 재귀 부분에서는 '이전 결과'와 '원본 테이블'을 조인하여 관계를 확장해나감.

- **비교 / 확장**:
  - 일반 `JOIN`은 고정된 횟수만큼 테이블을 연결하지만, 재귀 CTE는 데이터의 깊이만큼 동적으로 반복 수행됨.
  - 재귀를 사용하지 않으면 여러 단계의 `SELF JOIN`이 필요해 쿼리가 길고 복잡해짐.

- **관련 문제**:
  - `특정 세대의 대장균 찾기`, `멸종위기의 대장균 찾기`

### [핵심 개념: 윈도우 함수 (Window Functions)]

- **개념**:
  - `GROUP BY`처럼 행을 그룹으로 묶지 않고, 각 행에 대해 순위, 백분율, 누적 합계 등을 계산.
  - `OVER()` 절을 통해 계산의 대상이 될 행의 집합(window)을 정의.

- **언제 사용하는가?**:
  - '대장균의 크기에 따라 분류하기 2'처럼 전체 데이터 내에서 각 행의 상대적 위치(순위, 백분율)를 찾아야 할 때.
  - 부서별 급여 순위, 누적 매출 계산 등.

- **쿼리 관점 포인트**:
  - `PARTITION BY`로 그룹을 나눌지, `ORDER BY`로 순서를 정할지를 `OVER()` 절에 명시하는 것이 핵심.
  - `PERCENT_RANK`, `RANK`, `DENSE_RANK`, `ROW_NUMBER` 등 유사한 함수들의 미묘한 차이를 이해하고 문제에 맞는 것을 선택해야 함.

- **비교 / 확장**:
  - `GROUP BY`는 그룹당 하나의 결과 행을 반환하지만, 윈도우 함수는 원래 행의 수를 그대로 유지함.
  - 집계 함수(`SUM`, `AVG` 등)도 `OVER()`와 함께 쓰면 윈도우 함수처럼 동작 가능.

- **관련 문제**:
  - `대장균의 크기에 따라 분류하기 2`

### [핵심 개념: NOT EXISTS]

- **개념**:
  - 서브쿼리의 결과가 비어있을 때 `TRUE`를 반환하는 조건.
  - 메인 쿼리의 각 행에 대해 서브쿼리가 실행되며, 상관관계(Correlated Subquery)를 가짐.

- **언제 사용하는가?**:
  - '멸종위기의 대장균 찾기'처럼 'A에는 있지만 B에는 없는' 데이터를 찾을 때.
  - 주문 이력이 없는 고객, 자식 노드가 없는 부모 노드 등을 찾을 때 매우 유용.

- **쿼리 관점 포인트**:
  - 서브쿼리 내 `WHERE` 절에서 메인 쿼리의 컬럼을 참조하여 연결고리를 만드는 것이 중요.
  - `SELECT` 절에는 보통 `1`이나 `*`를 사용하여 존재 여부만 확인하므로 성능에 영향을 주지 않음.

- **비교 / 확장**:
  - `NOT IN`: 서브쿼리 결과에 `NULL`이 있으면 예상과 다르게 동작할 수 있음. `NOT EXISTS`는 `NULL`에 대해 더 안전하고 일관된 결과를 제공함.
  - 대용량 데이터에서는 인덱스를 효율적으로 사용할 수 있는 `NOT EXISTS`가 `NOT IN`보다 일반적으로 성능이 좋음.

- **관련 문제**:
  - `멸종위기의 대장균 찾기`

### [핵심 개념: HAVING vs WHERE]

- **개념**:
  - `WHERE`: `FROM`절에서 읽어온 개별 행을 `GROUP BY` 하기 전에 필터링.
  - `HAVING`: `GROUP BY`로 집계된 결과 그룹을 필터링.

- **언제 사용하는가?**:
  - `WHERE`: 집계 함수와 무관한 일반 조건으로 행을 필터링할 때.
  - `HAVING`: `AVG(price) > 100`, `COUNT(id) > 5`처럼 집계 함수의 결과값을 조건으로 사용할 때.

- **쿼리 관점 포인트**:
  - 쿼리 실행 순서(`FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY`)를 이해하면 둘의 차이를 명확히 알 수 있음.
  - 가능한 한 `WHERE` 절에서 먼저 필터링하는 것이 `GROUP BY`할 데이터 양을 줄여 성능에 유리함.

- **비교 / 확장**:
  - `WHERE`에는 집계 함수를 쓸 수 없지만, `HAVING`에는 일반 조건과 집계 함수 조건을 모두 쓸 수 있음 (하지만 일반 조건은 `WHERE`에 쓰는 것이 더 효율적).

- **관련 문제**:
  - `평균 일일 대여 요금 구하기`